<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<!-- <link rel="icon" href="./favicon.png" /> -->
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="./_app/immutable/assets/0.CczKcHiT.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.C2f8M1sw.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/HmGoMqso.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dxtxyj28.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DK8D298C.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/JY5l5D6Y.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/eVigdbh7.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.BlLZjZCz.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dp1pzeXC.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Bzak7iHL.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DHz2Y3yU.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CSz6k_A3.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.DoJJaxG3.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CcL8L1UM.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DLrSe-_4.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Bx_LN-Xl.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CcjtmNi5.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/3.HhoYlhRm.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/GlCF_tPK.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dq1ptKLK.js"><!--[--><link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300&amp;display=swap" rel="stylesheet"/><!--]-->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><nav class="bg-yellow-50 p-4 flex justify-center gap-10 shadow-sm"><!--[--><a href="./" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">About</a><a href="./feed" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">Feed</a><a href="./til" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">TIL</a><a href="./lab" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">Lab</a><!--]--></nav> <main class="min-h-screen flex flex-col items-center justify-center bg-yellow-50 text-black px-4" style="font-family: 'Montserrat', sans-serif;"><!----><!----><section class="w-full max-w-5xl mx-auto px-6 pt-4 pb-16 space-y-8"><!--[--><article><div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><div class="flex items-baseline justify-between mb-2">
  <h1 class="text-2xl font-light tracking-tight">A cookbook for a weather station — Part II</h1>
  <time class="text-sm text-gray-600 ml-4">September 3, 2025</time>
</div>

<h2>Collecting and archiving measurement data</h2>
<p>In part I of my weather station cookbook, I wrote about setting up and publishing sensor data to <code>MQTT</code> using an <code>Arduino</code>. In this post, I’ll focus on storing that data so it can be analyzed over time.</p>
<p><code>MQTT</code> only keeps the latest value, so to create a proper history, I decided to save everything in a database  — in <code>SQLite</code> because it’s file-based — you can open it directly, inspect the data, or even move it like any other file.</p>
<p>A tidbit diverging from the name of this blog, I implemented the logger in <code>Rust</code> instead of <code>Python</code>.</p>
<p>The script itself is pretty simple:</p>
<ul>
<li>it sets up the <code>SQLite</code> database and ensures the measurements table exists:</li>
</ul>

      <div class="code-block">
        <small class="language-label">rust</small>
        <pre><code class="language-rust">use rusqlite::Connection;

...

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> { 
    let conn = Connection::open("weather_station.db").expect("Failed to open DB");
        conn.execute(
            "CREATE TABLE IF NOT EXISTS measurements (
                timestamp TEXT NOT NULL,
                value REAL NOT NULL,
                metric TEXT NOT NULL,
                unit TEXT NOT NULL
            )",
            [],
        )?;   

    ...

}</code></pre>
      </div>
    <ul>
<li>it configures and connects the <code>MQTT</code> client to the broker and subscribes to the <strong>temperature</strong> and <strong>humidity</strong> topics:</li>
</ul>

      <div class="code-block">
        <small class="language-label">rust</small>
        <pre><code class="language-rust">use rumqttc::{MqttOptions, Client, QoS};
use std::time::Duration;

...

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let mut mqttoptions = MqttOptions::new("mqtt_logger", "localhost", 1883);

    mqttoptions.set_keep_alive(Duration::from_secs(15 * 60));

    mqttoptions.set_clean_session(false);

    let (client, mut eventloop) = Client::new(mqttoptions, 10);
    client.subscribe("weather/indoor-sensor/temperature", QoS::AtMostOnce)?;
    client.subscribe("weather/indoor-sensor/humidity", QoS::AtMostOnce)?;

    ...

}</code></pre>
      </div>
    <ul>
<li>it continuously listens for incoming messages in a dedicated thread, which parses each message from <code>json</code> and inserts it into the database - errors in parsing or database operations are logged, and the <code>MQTT</code> connection automatically retries on failure:</li>
</ul>

      <div class="code-block">
        <small class="language-label">rust</small>
        <pre><code class="language-rust">use rusqlite::params;
use serde::Deserialize;
use serde_json;
use std::thread;

#[derive(Deserialize)]
struct SensorPayload {
    timestamp: i64,
    metric: String,
    value: f64,
    unit: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ...

    let handle = thread::spawn(move || {
        for message in eventloop.iter() {
            match message {
                Ok(rumqttc::Event::Incoming(rumqttc::Packet::Publish(p))) => {
                    if let Ok(text) = String::from_utf8(p.payload.to_vec()) {
                        match serde_json::from_str::<SensorPayload>(&text) {
                        Ok(data) => {
                            if let Err(e) = conn.execute(
                                    "INSERT INTO measurements
                                        (timestamp, value, metric, unit)
                                    VALUES (?1, ?2, ?3, ?4)",
                                    params![
                                        data.timestamp,
                                        data.value,
                                        data.metric,
                                        data.unit
                                    ],
                                )  {
                                    eprintln!("DB insert error: {}", e);
                                } else {
                                    println!("Inserted @ {}", data.timestamp);
                                }
                            }
                            Err(e) => eprintln!("JSON parse error: {}", e),
                        }
                    }
                }
                Ok(_) => {}
                Err(e) => {
                    eprintln!("MQTT error: {} — reconnecting in 5s", e);
                    std::thread::sleep(std::time::Duration::from_secs(5));
                }
            }
        }
    });

    ...

}</code></pre>
      </div>
    <ul>
<li>the main thread is blocked until the <code>MQTT</code> thread finishes - in practice it runs forever:</li>
</ul>

      <div class="code-block">
        <small class="language-label">rust</small>
        <pre><code class="language-rust">
...

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ...

    let handle = ... ;

    handle.join().unwrap();

    Ok(())
}</code></pre>
      </div>
    <!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><div class="flex items-baseline justify-between mb-2">
  <h1 class="text-2xl font-light tracking-tight">A cookbook for a weather station — Part I</h1>
  <time class="text-sm text-gray-600 ml-4">September 1, 2025</time>
</div>

<p>Have you ever wondered how to measure <strong>temperature</strong> and <strong>humidity</strong>?</p>
<p>I decided to explore it by building my own setup from <strong>sensor</strong> to <strong>display</strong>:</p>
<div class="mermaid">flowchart TD
    ESP["🔌 NodeMCU ESP8266"] -->|Digital Pin| DHT["🌡️ DHT22 Sensor"]
    ESP -->|Wi-Fi / MQTT Publish| MQTT["📡 MQTT Broker"]

    subgraph "🍓 Raspberry Pi"
        direction TB
        MQTT
        Rust["🦀 Rust Logger"]
        DB["🗄️ SQLite Database"]
        HA["🏠 Home Assistant"]
    end

    Rust -->|Subscribes to topic| MQTT
    Rust -->|Writes data to| DB
    HA -->|Reads data from| MQTT</div><table>
<thead>
<tr>
<th>Hardware stack</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://store.arduino.cc/products/nodemcu-esp8266">NodeMCU ESP8266</a></strong></td>
<td>acts as the &quot;brain&quot; of the weather station - reads data from the sensor and forwards it via Wi-Fi</td>
</tr>
<tr>
<td><strong><a href="https://store.arduino.cc/products/grove-temperature-humidity-sensor-pro">DHT22</a></strong></td>
<td>measures <strong>temperature</strong> and <strong>humidity</strong></td>
</tr>
<tr>
<td><strong><a href="https://www.raspberrypi.com">Raspberry Pi</a></strong></td>
<td>hosts an <code>MQTT</code> client that receives weather data published via the <code>NodeMCU ESP8266</code> over Wi-Fi, allowing the data to be stored, processed, and shared</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Software stack</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://mqtt.org">MQTT</a></strong></td>
<td>messaging protocol for <code>IoT</code> using a publish/subscribe system</td>
</tr>
<tr>
<td><strong><a href="https://docs.arduino.cc/arduino-cloud/guides/arduino-c/">Arduino / C++</a></strong></td>
<td><code>NodeMCU ESP8266</code> runs <code>Arduino/C++</code> code to read data from the sensor and publish to the <code>MQTT</code> topics</td>
</tr>
<tr>
<td><strong><a href="https://www.home-assistant.io/integrations/sensor.mqtt/">Home Assistant</a></strong></td>
<td>subscribes to the <code>MQTT</code> topics to receive and display the measurements</td>
</tr>
<tr>
<td><strong><a href="https://sqlite.org">SQLite</a></strong></td>
<td>database to archive and store the weather station’s historical data on the <code>Raspberry Pi</code></td>
</tr>
<tr>
<td><strong><a href="https://www.rust-lang.org">Rust</a></strong></td>
<td>implements a logger that saves incoming <code>MQTT</code> weather data into the <code>SQLite</code> database</td>
</tr>
</tbody></table>
<h2>Assembling the sensor</h2>
<p>To connect a <code>DHT22</code> <strong>temperature</strong> and <strong>humidity</strong> sensor to the <code>NodeMCU ESP8266</code>, wire the <code>VCC</code> pin of the <code>DHT22</code> to the <code>NodeMCU ESP8266</code>’s <strong>3.3V</strong> pin and the <code>GND</code> pin to a <code>GND</code> pin on the <code>NodeMCU ESP8266</code>. Then connect the <code>Data</code> pin to the digital pin (<code>D2</code>) on the <code>NodeMCU ESP8266</code>.</p>
<p>If you want a visual walkthrough, Arduino provides an <a href="https://arduinogetstarted.com/tutorials/arduino-dht22">official tutorial</a> that covers this step-by-step.</p>
<h2>Retrieving <strong>temperature</strong> and <strong>humidity</strong> values</h2>
<p>The <code>NodeMCU ESP8266</code> and <code>DHT22</code> sensor work together: every 10 minutes, the device connects to Wi-Fi and syncs its clock with an <code>NTP</code> server to get the correct time:</p>

      <div class="code-block">
        <small class="language-label">cpp</small>
        <pre><code class="language-cpp">#include &lt;WiFiUdp.h&gt;
#include &lt;NTPClient.h&gt;

...

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 0, 60000);

...

timeClient.update();</code></pre>
      </div>
    <p>The <strong><a href="https://docs.arduino.cc/libraries/dht22/">DHT22</a></strong> library handles updating <strong>temperature</strong> and <strong>humidity</strong> values:</p>

      <div class="code-block">
        <small class="language-label">cpp</small>
        <pre><code class="language-cpp">#include &lt;DHT22.h&gt;

...

#define pinDATA SDA

...

DHT22 dht22(pinDATA);

...

float humidity = dht22.getHumidity();
float temperature = dht22.getTemperature();</code></pre>
      </div>
    <h2>Publishing data to <code>MQTT</code></h2>
<p>Since <code>NodeMCU ESP8266</code> has a Wi-Fi module, the measured values can be published to an <code>MQTT</code> client hosted on a <code>Raspberry Pi</code>.</p>
<p>The board first joins the Wi-Fi network:</p>

      <div class="code-block">
        <small class="language-label">cpp</small>
        <pre><code class="language-cpp">#include &lt;ESP8266WiFi.h&gt;

...

WiFiClient espClient;

...

const char* ssid = "ssid";
const char* password = "password";

...

void setup_wifi() {
  delay(10);
  Serial.println("Connecting to WiFi ...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected. IP: ");
  Serial.println(WiFi.localIP());
}</code></pre>
      </div>
    <p>With the Wi-Fi connection available, the board can publish data to <code>MQTT</code>:</p>

      <div class="code-block">
        <small class="language-label">cpp</small>
        <pre><code class="language-cpp">#include &lt;PubSubClient.h&gt;


...

PubSubClient client(espClient);

...

const int mqtt_port = 1883;
const char* mqtt_server = "mqtt_server";

...

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection ...");
    if (client.connect("NodeMCUClient")) {
      Serial.println("connected");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" retrying in 5 seconds");
      delay(5000);
    }
  }
}

...

void setup() {
  Serial.begin(115200);
  setup_wifi();
  client.setServer(mqtt_server, mqtt_port);
  timeClient.begin();
}

...

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  timeClient.update();

  ...

}</code></pre>
      </div>
    <p>Sensor measurements are sent as <code>json</code> messages containing the <code>metric</code>, <code>value</code>, <code>unit</code>, <code>timestamp</code>, and published via <code>MQTT</code> to designated topics. Since the <code>NodeMCU ESP8266</code> transmits every 10 minutes, the buffer time is sufficient to capture all measurements.</p>

      <div class="code-block">
        <small class="language-label">cpp</small>
        <pre><code class="language-cpp">const char* mqtt_temperature_topic = "weather/indoor-sensor/temperature";
const char* mqtt_humidity_topic = "weather/indoor-sensor/humidity";

...

void loop() {
  // Check if readings are valid
  if (!isnan(humidity) && !isnan(temperature)) {
    unsigned long timestamp = timeClient.getEpochTime();

    // Prepare temperature payload as JSON
    String temperature_payload = "{\"metric\": \"temperature\", \"value\": " + String(temperature) + ", \"unit\": \"℃\", \"timestamp\": " + String((uint64_t)timestamp) + "}";

    // Prepare humidity payload as JSON
    String humidity_payload = "{\"metric\": \"humidity\", \"value\": " + String(humidity) + ", \"unit\": \"%\", \"timestamp\": " + String((uint64_t)timestamp) + "}";

    // Publish temperature
    client.publish(mqtt_temperature_topic, temperature_payload.c_str());
    Serial.println("Published temperature: " + temperature_payload);

    // Publish humidity
    client.publish(mqtt_humidity_topic, humidity_payload.c_str());
    Serial.println("Published humidity: " + humidity_payload);

  } else {
    Serial.println("Failed to read from DHT sensor");
  }

  delay(600000);

}</code></pre>
      </div>
    <h2>Syncing with <code>Home Assistant</code></h2>
<p>Once the data lands in <code>MQTT</code>, the measurements can be displayed in <code>Home Assistant</code> configuring <a href="https://www.home-assistant.io/integrations/sensor.mqtt/">MQTT Sensor</a>.</p>
<h2>Up next</h2>
<p>In the next part, I’ll dive into my <code>Rust</code>-based logger and share how it works.</p>
<p>Stay tuned, Pyrsuers! 🐍</p>
<p><em>If you would like to check out the entire project, it is available in my <a href="https://github.com/pyrsuit/weather-station/tree/main">weather-station</a> repo.</em></p>
<!----></div> <!--[!--><!--]--></article><!--]--></section><!----><!----></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_1dj87p5 = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/pyrsuit-dev-blog"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.C2f8M1sw.js"),
						import("./_app/immutable/entry/app.BlLZjZCz.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data: [null,null],
							form: null,
							error: null,
							remote: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
