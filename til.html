<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<!-- <link rel="icon" href="./favicon.png" /> -->
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="./_app/immutable/assets/0.zjr9RkKc.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.8AgDhh3Z.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DLvnVAYR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dxtxyj28.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DK8D298C.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/JY5l5D6Y.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/eVigdbh7.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.CPnTY5is.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dp1pzeXC.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Bzak7iHL.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DHz2Y3yU.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CSz6k_A3.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.BrenXiVF.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CcL8L1UM.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DLrSe-_4.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Bx_LN-Xl.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CcjtmNi5.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/5.D-3aaZie.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dq1ptKLK.js"><!--[--><link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300&amp;display=swap" rel="stylesheet"/><!--]-->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><nav class="bg-yellow-50 p-4 flex justify-center gap-10 shadow-sm"><!--[--><a href="./" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">About</a><a href="./feed" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">Feed</a><a href="./til" class="text-black tracking-wide text-center cursor-pointer transition-all duration-300 font-extralight hover:font-semibold svelte-1jhqufd" style="font-family: 'Montserrat', sans-serif;">TIL</a><!--]--></nav> <main class="min-h-screen flex flex-col items-center justify-center bg-yellow-50 text-black px-4" style="font-family: 'Montserrat', sans-serif;"><!----><!----><section class="w-full max-w-5xl mx-auto px-6 pt-4 pb-16 space-y-8"><!--[--><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">"Compile me!" 🫖</h1> <time class="text-sm text-gray-600 ml-4">2025-10-03</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>Deciding whether to <code>re.compile</code> a <strong>regex</strong> is a bit like Alice pondering the bottle labeled <em>“Drink me!”</em> - it&#39;s about picking the best option for the situation.</p>
<ul>
<li><strong>One-off search</strong>: A small sip with minimal effect and negligible overhead. If you only plan to run the <strong>regex</strong> once, there&#39;s no benefit to compiling it - <strong>Python</strong> will take care of that automatically when <code>re.search</code> is invoked.</li>
</ul>

      <div class="code-block">
        <small class="language-label">python</small>
        <pre><code class="language-python">import re

if re.search(r"\bwhite\s+rabbit\b", "Alice chased the white rabbit into the hole."):
    print("Found the white rabbit!")</code></pre>
      </div>
    <ul>
<li><strong>Repeated use:</strong> A generous sip with a noticeable impact. Each call to <code>re.search</code> inside a loop would recompile the <strong>regex</strong>, creating overhead. When compiling the pattern once, multiple searches can reuse it and save time.</li>
</ul>

      <div class="code-block">
        <small class="language-label">python</small>
        <pre><code class="language-python">import re

texts = [
    "Alice quickly ran after the white rabbit as it disappeared behind the bushes.",
    "The white rabbit looked at its pocket watch anxiously before hopping away."
]

pattern = re.compile(r"\bwhite\s+rabbit\b")

for text in texts:
    if pattern.search(text):
        print("Found the white rabbit!")</code></pre>
      </div>
    <p>✅ Reuse → compile.
❌ One-off → skip it.</p>
<p>💡 <strong>Takeaway</strong>: For repeated use, compile your regex - otherwise it&#39;ll end up like the white rabbit, frantically rushing: <em>&quot;Oh dear, oh dear, I shall be late — I got a match!&quot;</em></p>
<!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">Non-public 🚫 vs protected 🛡️</h1> <time class="text-sm text-gray-600 ml-4">2025-09-27</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>⚠️ <strong>Disclaimer</strong>: If you&#39;re coming from an OOP background, you may find the following content disturbing. Read at your own risk.</p>
<p><strong>Python</strong> doesn&#39;t do strict access control, a single underscore means <strong>private by convention</strong>, while a double underscore triggers <strong>name mangling</strong> to protect attributes from being accidentally overridden in subclasses.</p>
<p>But what happens if a subclass defines its own double underscore attribute? How does a single-underscore variable differ from a double underscore variable in practice?</p>
<p>For example, the base <code>Metric</code> class has <code>__storage</code> and a <code>_mean</code>:</p>

      <div class="code-block">
        <small class="language-label">python</small>
        <pre><code class="language-python">class Metric:
    def __init__(self):
        self.__storage = []  # double underscore → protected
        self._mean = None  # single underscore → private

    def add(self, num):
        self.__storage.append(num)
        self._mean = None

    def mean(self):
        if self._mean is None:
            self._mean = sum(self.__storage) / len(self.__storage)
        return self._mean

m = Metric()
m.add(5)
m.add(8)
print("Metric mean:", m.mean())  # 6.5
print("Metric __dict__:", m.__dict__)  # {'_Metric__storage': [5, 8], '_mean': 6.5}</code></pre>
      </div>
    <p>A subclass can define its own double underscore attribute without overwriting the parent:</p>

      <div class="code-block">
        <small class="language-label">python</small>
        <pre><code class="language-python">class MaxMetric(Metric):
    def __init__(self):
        super().__init__()
        self.__storage = None  # subclass storage, mangled separately

    def add(self, num):
        super().add(num)
        if self.__storage is None or num > self.__storage:
            self.__storage = num

    def max(self):
        return self.__storage

mm = MaxMetric()
mm.add(3)
mm.add(10)
mm.add(7)
print("MaxMetric mean:", mm.mean())  # 6.666666666666667
print("MaxMetric max:", mm.max())  # 10
print("MaxMetric __dict__:", mm.__dict__)
# {'_Metric__storage': [3, 10, 7], '_mean': 6.666666666666667, '_MaxMetric__storage': 10}</code></pre>
      </div>
    <p>💡 <strong>Takeaway</strong>: Use <strong>single</strong> underscore for helpers or temporary state, <strong>double</strong> underscore for critical storage that shouldn&#39;t be accidentally overridden.</p>
<!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">Walrus operator: assign on the fly 🛫</h1> <time class="text-sm text-gray-600 ml-4">2025-08-25</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>I recently discovered that Python has a neat operator for assigning a value and using it immediately: the <code>:=</code> operator, also called the walrus operator.</p>
<p>For example, instead of:</p>

      <div class="code-block">
        <small class="language-label">python</small>
        <pre><code class="language-python">value = data.get("key")
if value:
    print(len(value))</code></pre>
      </div>
    <p>You can do:</p>

      <div class="code-block">
        <small class="language-label">python</small>
        <pre><code class="language-python">if (value := data.get("key")):
    print(len(value))</code></pre>
      </div>
    <p>Boom 💥 value is assigned and ready to roll.</p>
<p>💡 <strong>Takeaway</strong>: <code>:=</code> = assign inline, use instantly, keep it neat.</p>
<!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">The one when TRUNCATE locked me out 🚪🔒</h1> <time class="text-sm text-gray-600 ml-4">2025-08-19</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>While running <code>pytest</code> with <code>MySQL</code>, I kept hitting tests stuck on: <code>Waiting for table metadata lock</code> 😫 </p>
<p>Digging in, I found the culprit: my fixtures were using <code>TRUNCATE TABLE</code> to clean test data between runs. </p>
<p>Here&#39;s the catch: In MySQL, <code>TRUNCATE</code> is <strong><a href="https://en.wikipedia.org/wiki/Data_definition_language">DDL</a></strong>, not <strong><a href="https://en.wikipedia.org/wiki/Data_manipulation_language">DML</a></strong>. It drops/recreates the table under the hood, resets <code>AUTO_INCREMENT</code>, and requires an <strong>exclusive metadata lock</strong>. If any transaction has touched the table — even just a <code>SELECT</code> — <code>TRUNCATE</code> will block until that lock is released. In <code>pytest</code>, with long-lived connections, this happened constantly. </p>
<p>✅ <strong>Fix:</strong> switched to <code>DELETE FROM</code> table for cleanup. <code>DELETE</code> is <code>DML</code>, transactional, and only takes row locks + short metadata locks. It doesn&#39;t reset <code>AUTO_INCREMENT</code>, but it doesn&#39;t block other transactions either. </p>
<p>💡 <strong>Takeaway:</strong>: In <code>MySQL</code> tests, prefer <code>DELETE</code> over TRUNCATE unless you can guarantee no open transactions. </p>
<p>🔄 <strong>Postgres comparison</strong>: <code>TRUNCATE</code> in <code>Postgres</code> is transactional — you can roll it back, and it doesn&#39;t block in the same way. It still takes stricter locks than <code>DELETE</code>, but because <code>Postgres</code> metadata locking is less rigid, it rarely causes the same “hung DDL” issues you see in <code>MySQL</code>.</p>
<!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">When metrics eat your memory 🧠 🍽️</h1> <time class="text-sm text-gray-600 ml-4">2025-07-24</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>Follow-up to my earlier post on Prometheus + Multiprocess Apps ... </p>
<p>A few days in, I noticed the metrics directory was ballooning in memory 🎈 </p>
<p>Digging in, I realized the Prometheus Python client (in multiprocess mode) writes separate files per metric per process. By default, those files are named things like <code>counter_12345.db</code>, where <code>12345</code> is the PID.</p>
<p>So when a <code>uWSGI</code> worker dies and gets replaced — totally normal behavior — the new process gets its own set of metric files. But the old files? They just stay there.</p>
<p>Since the client doesn’t automatically clean up stale files, the directory just keeps growing.</p>
<p>✅ Fix: I configured a cleanup step to remove metrics for dead processes.</p>
<p>💡 Takeaway: In multiprocess mode, the metrics client tracks data per PID. Without cleanup, these files accumulate and quietly consume memory — especially in environments with frequent process restarts.</p>
<!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">Goodbye temp venv hacks 👋</h1> <time class="text-sm text-gray-600 ml-4">2025-07-19</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>Today I learned how much I enjoy using <code>uv</code> scripts for quick, one-off tasks.</p>
<p>You can define dependencies right at the top of the script, and when you run it with <code>uv</code>, it spins up a temporary virtual environment automatically. Once the script finishes, the environment is destroyed — super clean 🧹</p>
<p>This is perfect for things like initial tasks when starting a container, or scripts that import data, run a migration, or do any kind of setup that isn&#39;t needed once the main app is running.</p>
<p>💡 <strong>Takeaway</strong>: <strong><a href="https://docs.astral.sh/uv/guides/scripts/">uv scripts</a></strong> give you a disposable, isolated environment without any manual setup — ideal for clean, repeatable scripting without leaving a mess behind.</p>
<!----></div> <!--[--><hr class="border-t border-gray-300 mt-6"/><!--]--></article><article><div class="flex items-baseline justify-between mb-2"><h1 class="text-2xl font-light tracking-tight">Prometheus + multiprocess apps: A lesson from the trenches</h1> <time class="text-sm text-gray-600 ml-4">2025-07-13</time></div> <div class="markdown-content text-base text-gray-800 leading-relaxed"><!----><p>I recently deployed an API using <code>uWSGI</code> with multiple workers. I exposed a <code>/metrics</code> endpoint for <code>Prometheus</code> scraping — all looked good.</p>
<p>Until I realized… the metrics were off 🫠</p>
<p>Turns out, when you&#39;re using multiple <code>uWSGI</code> workers, <code>Prometheus</code>&#39; Python client needs <strong>multiprocess mode</strong> enabled to aggregate metrics across all worker processes. Without it, each process exposes its own separate metrics — so counters, for example, appear to jump up and down instead of increasing cumulatively across all workers. </p>
<p>✅ <strong>Fix:</strong> Configured <strong><a href="https://prometheus.github.io/client_python/multiprocess/">multiprocess mode</a></strong>, so all workers write metrics to a shared directory.</p>
<p>💡 <strong>Takeaway</strong>: With multiple workers per replica, <code>Prometheus</code> scrapes the <code>/metrics</code> endpoint from only one worker per replica at random — so without multiprocess mode, your <code>Prometheus</code> metrics won&#39;t reflect the true state of your API — making it impossible to accurately track what&#39;s really happening.</p>
<!----></div> <!--[!--><!--]--></article><!--]--></section><!----><!----></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_20of3x = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/pyrsuit-dev-blog"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.8AgDhh3Z.js"),
						import("./_app/immutable/entry/app.CPnTY5is.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 5],
							data: [null,null],
							form: null,
							error: null,
							remote: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
